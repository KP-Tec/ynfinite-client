/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ (function() {

function handleResponse(e, t) {
  t.json().then((t) => {
    const { success, error, inline: n, redirect: o, type: i } = t;

    if (success) {
      "information" === i && (e.innerHTML = n[0].template),
        "redirect" === i && window.location.replace(o),
        "inline" === i &&
          n.forEach((e) => {
            if (e.selector) {
              const t = e.selector.substring(1);
              if ("." === e.selector.charAt(0)) {
                document.getElementsByClassName(t).forEach((t) => {
                  t.innerHTML = e.template;
                });
              }
              if ("#" === e.selector.charAt(0)) {
                document.getElementsByClassName(t).innerHTML = e.template;
              }
            }
          });
    } else {
      const errorContainer = e.querySelector(".yn-error");
      errorContainer.innerHTML =
        "<ul><li data-status='" +
        error.status +
        "'>" +
        error.message +
        "</li></ul>";
    }
  });
}

function functSubmit(e) {
  e.preventDefault();
  const t = e.target,
    n = new FormData(t),
    o = e.target.getAttribute("data-ynfiniteid"),
    i = e.target.getAttribute("data-ynfinitelang"),
    c = e.target.getAttribute("data-ynfinite-content"),
    s = e.target.getAttribute("data-ynfinite-section"),
    sp = e.target.getAttribute("data-ynfinite-slugprefix");
  n.append("formId", o),
    n.append("lang", i),
    n.append("prefix", sp),
    n.append("contentId", c),
    n.append("sectionId", s),
    n.append("action", "submit");

  fetch(t.action, {
    method: t.method,
    body: n,
  }).then(handleResponse.bind(null, t)),
    e.preventDefault();
}

function functOnInput(e) {
  const { form: t } = e.target,
    n = new FormData(t),
    o = t.getAttribute("data-ynfiniteid"),
    i = t.getAttribute("data-ynfinitelang");
  n.append("formId", o),
    n.append("lang", i),
    n.append("action", "change"),
    (("insertText" === e.inputType && e.target.value.length > 3) ||
      "insertText" !== e.inputType) &&
      fetch(t.action, {
        method: t.method,
        body: n,
      }).then(handleResponse.bind(null, t)),
    e.preventDefault();
}

const forms = document.querySelectorAll('*[data-ynfiniteform="true"]');
for (const e of forms) e.addEventListener("submit", functSubmit);
const onChangeForms = document.querySelectorAll(
  '*[data-ynfiniteform-onchange="true"]'
);
onChangeForms.forEach(function (e) {
  for (var t, n = 0; (t = e.elements[n++]); )
    t.addEventListener("input", functOnInput);
});
const buttons = document.querySelectorAll(".gdpr-button");
for (const e of buttons)
  e.addEventListener("click", function (e) {
    e.preventDefault();
    const t = e.target.getAttribute("data-formid"),
      n = e.target.getAttribute("data-formaction"),
      o = document.getElementById(t),
      i = new FormData(o);
    fetch(n || o.action, { method: o.method, body: i }).then((e) => {
      200 === e.status &&
        e.json().then((e) => {
          o.innerHTML = `<div class="response">${e.message}</div>`;
        });
    });
  });


/***/ }),
/* 2 */
/***/ (function(module) {

/*! lazysizes - v5.2.2 */

!function (e) {
    var t = function (u, D, f) {
        "use strict";
        var k, H;
        if (function () {
            var e;
            var t = {
                lazyClass: "lazyload",
                loadedClass: "lazyloaded",
                loadingClass: "lazyloading",
                preloadClass: "lazypreload",
                errorClass: "lazyerror",
                autosizesClass: "lazyautosizes",
                srcAttr: "data-src",
                srcsetAttr: "data-srcset",
                sizesAttr: "data-sizes",
                minSize: 40,
                customMedia: {},
                init: true,
                expFactor: 1.5,
                hFac: .8,
                loadMode: 2,
                loadHidden: true,
                ricTimeout: 0,
                throttleDelay: 125
            };
            H = u.lazySizesConfig || u.lazysizesConfig || {};
            for (e in t) {
                if (!(e in H)) {
                    H[e] = t[e]
                }
            }
        }(), !D || !D.getElementsByClassName) {
            return {
                init: function () {
                }, cfg: H, noSupport: true
            }
        }
        var O = D.documentElement, a = u.HTMLPictureElement, P = "addEventListener", $ = "getAttribute",
            q = u[P].bind(u), I = u.setTimeout, U = u.requestAnimationFrame || I, l = u.requestIdleCallback,
            j = /^picture$/i, r = ["load", "error", "lazyincluded", "_lazyloaded"], i = {}, G = Array.prototype.forEach,
            J = function (e, t) {
                if (!i[t]) {
                    i[t] = new RegExp("(\\s|^)" + t + "(\\s|$)")
                }
                return i[t].test(e[$]("class") || "") && i[t]
            }, K = function (e, t) {
                if (!J(e, t)) {
                    e.setAttribute("class", (e[$]("class") || "").trim() + " " + t)
                }
            }, Q = function (e, t) {
                var i;
                if (i = J(e, t)) {
                    e.setAttribute("class", (e[$]("class") || "").replace(i, " "))
                }
            }, V = function (t, i, e) {
                var a = e ? P : "removeEventListener";
                if (e) {
                    V(t, i)
                }
                r.forEach(function (e) {
                    t[a](e, i)
                })
            }, X = function (e, t, i, a, r) {
                var n = D.createEvent("Event");
                if (!i) {
                    i = {}
                }
                i.instance = k;
                n.initEvent(t, !a, !r);
                n.detail = i;
                e.dispatchEvent(n);
                return n
            }, Y = function (e, t) {
                var i;
                if (!a && (i = u.picturefill || H.pf)) {
                    if (t && t.src && !e[$]("srcset")) {
                        e.setAttribute("srcset", t.src)
                    }
                    i({reevaluate: true, elements: [e]})
                } else if (t && t.src) {
                    e.src = t.src
                }
            }, Z = function (e, t) {
                return (getComputedStyle(e, null) || {})[t]
            }, s = function (e, t, i) {
                i = i || e.offsetWidth;
                while (i < H.minSize && t && !e._lazysizesWidth) {
                    i = t.offsetWidth;
                    t = t.parentNode
                }
                return i
            }, ee = function () {
                var i, a;
                var t = [];
                var r = [];
                var n = t;
                var s = function () {
                    var e = n;
                    n = t.length ? r : t;
                    i = true;
                    a = false;
                    while (e.length) {
                        e.shift()()
                    }
                    i = false
                };
                var e = function (e, t) {
                    if (i && !t) {
                        e.apply(this, arguments)
                    } else {
                        n.push(e);
                        if (!a) {
                            a = true;
                            (D.hidden ? I : U)(s)
                        }
                    }
                };
                e._lsFlush = s;
                return e
            }(), te = function (i, e) {
                return e ? function () {
                    ee(i)
                } : function () {
                    var e = this;
                    var t = arguments;
                    ee(function () {
                        i.apply(e, t)
                    })
                }
            }, ie = function (e) {
                var i;
                var a = 0;
                var r = H.throttleDelay;
                var n = H.ricTimeout;
                var t = function () {
                    i = false;
                    a = f.now();
                    e()
                };
                var s = l && n > 49 ? function () {
                    l(t, {timeout: n});
                    if (n !== H.ricTimeout) {
                        n = H.ricTimeout
                    }
                } : te(function () {
                    I(t)
                }, true);
                return function (e) {
                    var t;
                    if (e = e === true) {
                        n = 33
                    }
                    if (i) {
                        return
                    }
                    i = true;
                    t = r - (f.now() - a);
                    if (t < 0) {
                        t = 0
                    }
                    if (e || t < 9) {
                        s()
                    } else {
                        I(s, t)
                    }
                }
            }, ae = function (e) {
                var t, i;
                var a = 99;
                var r = function () {
                    t = null;
                    e()
                };
                var n = function () {
                    var e = f.now() - i;
                    if (e < a) {
                        I(n, a - e)
                    } else {
                        (l || r)(r)
                    }
                };
                return function () {
                    i = f.now();
                    if (!t) {
                        t = I(n, a)
                    }
                }
            }, e = function () {
                var v, m, c, h, e;
                var y, z, g, p, C, b, A;
                var n = /^img$/i;
                var d = /^iframe$/i;
                var E = "onscroll" in u && !/(gle|ing)bot/.test(navigator.userAgent);
                var _ = 0;
                var w = 0;
                var N = 0;
                var M = -1;
                var x = function (e) {
                    N--;
                    if (!e || N < 0 || !e.target) {
                        N = 0
                    }
                };
                var W = function (e) {
                    if (A == null) {
                        A = Z(D.body, "visibility") == "hidden"
                    }
                    return A || !(Z(e.parentNode, "visibility") == "hidden" && Z(e, "visibility") == "hidden")
                };
                var S = function (e, t) {
                    var i;
                    var a = e;
                    var r = W(e);
                    g -= t;
                    b += t;
                    p -= t;
                    C += t;
                    while (r && (a = a.offsetParent) && a != D.body && a != O) {
                        r = (Z(a, "opacity") || 1) > 0;
                        if (r && Z(a, "overflow") != "visible") {
                            i = a.getBoundingClientRect();
                            r = C > i.left && p < i.right && b > i.top - 1 && g < i.bottom + 1
                        }
                    }
                    return r
                };
                var t = function () {
                    var e, t, i, a, r, n, s, l, o, u, f, c;
                    var d = k.elements;
                    if ((h = H.loadMode) && N < 8 && (e = d.length)) {
                        t = 0;
                        M++;
                        for (; t < e; t++) {
                            if (!d[t] || d[t]._lazyRace) {
                                continue
                            }
                            if (!E || k.prematureUnveil && k.prematureUnveil(d[t])) {
                                R(d[t]);
                                continue
                            }
                            if (!(l = d[t][$]("data-expand")) || !(n = l * 1)) {
                                n = w
                            }
                            if (!u) {
                                u = !H.expand || H.expand < 1 ? O.clientHeight > 500 && O.clientWidth > 500 ? 500 : 370 : H.expand;
                                k._defEx = u;
                                f = u * H.expFactor;
                                c = H.hFac;
                                A = null;
                                if (w < f && N < 1 && M > 2 && h > 2 && !D.hidden) {
                                    w = f;
                                    M = 0
                                } else if (h > 1 && M > 1 && N < 6) {
                                    w = u
                                } else {
                                    w = _
                                }
                            }
                            if (o !== n) {
                                y = innerWidth + n * c;
                                z = innerHeight + n;
                                s = n * -1;
                                o = n
                            }
                            i = d[t].getBoundingClientRect();
                            if ((b = i.bottom) >= s && (g = i.top) <= z && (C = i.right) >= s * c && (p = i.left) <= y && (b || C || p || g) && (H.loadHidden || W(d[t])) && (m && N < 3 && !l && (h < 3 || M < 4) || S(d[t], n))) {
                                R(d[t]);
                                r = true;
                                if (N > 9) {
                                    break
                                }
                            } else if (!r && m && !a && N < 4 && M < 4 && h > 2 && (v[0] || H.preloadAfterLoad) && (v[0] || !l && (b || C || p || g || d[t][$](H.sizesAttr) != "auto"))) {
                                a = v[0] || d[t]
                            }
                        }
                        if (a && !r) {
                            R(a)
                        }
                    }
                };
                var i = ie(t);
                var B = function (e) {
                    var t = e.target;
                    if (t._lazyCache) {
                        delete t._lazyCache;
                        return
                    }
                    x(e);
                    K(t, H.loadedClass);
                    Q(t, H.loadingClass);
                    V(t, L);
                    X(t, "lazyloaded")
                };
                var a = te(B);
                var L = function (e) {
                    a({target: e.target})
                };
                var T = function (t, i) {
                    try {
                        t.contentWindow.location.replace(i)
                    } catch (e) {
                        t.src = i
                    }
                };
                var F = function (e) {
                    var t;
                    var i = e[$](H.srcsetAttr);
                    if (t = H.customMedia[e[$]("data-media") || e[$]("media")]) {
                        e.setAttribute("media", t)
                    }
                    if (i) {
                        e.setAttribute("srcset", i)
                    }
                };
                var s = te(function (t, e, i, a, r) {
                    var n, s, l, o, u, f;
                    if (!(u = X(t, "lazybeforeunveil", e)).defaultPrevented) {
                        if (a) {
                            if (i) {
                                K(t, H.autosizesClass)
                            } else {
                                t.setAttribute("sizes", a)
                            }
                        }
                        s = t[$](H.srcsetAttr);
                        n = t[$](H.srcAttr);
                        if (r) {
                            l = t.parentNode;
                            o = l && j.test(l.nodeName || "")
                        }
                        f = e.firesLoad || "src" in t && (s || n || o);
                        u = {target: t};
                        K(t, H.loadingClass);
                        if (f) {
                            clearTimeout(c);
                            c = I(x, 2500);
                            V(t, L, true)
                        }
                        if (o) {
                            G.call(l.getElementsByTagName("source"), F)
                        }
                        if (s) {
                            t.setAttribute("srcset", s)
                        } else if (n && !o) {
                            if (d.test(t.nodeName)) {
                                T(t, n)
                            } else {
                                t.src = n
                            }
                        }
                        if (r && (s || o)) {
                            Y(t, {src: n})
                        }
                    }
                    if (t._lazyRace) {
                        delete t._lazyRace
                    }
                    Q(t, H.lazyClass);
                    ee(function () {
                        var e = t.complete && t.naturalWidth > 1;
                        if (!f || e) {
                            if (e) {
                                K(t, "ls-is-cached")
                            }
                            B(u);
                            t._lazyCache = true;
                            I(function () {
                                if ("_lazyCache" in t) {
                                    delete t._lazyCache
                                }
                            }, 9)
                        }
                        if (t.loading == "lazy") {
                            N--
                        }
                    }, true)
                });
                var R = function (e) {
                    if (e._lazyRace) {
                        return
                    }
                    var t;
                    var i = n.test(e.nodeName);
                    var a = i && (e[$](H.sizesAttr) || e[$]("sizes"));
                    var r = a == "auto";
                    if ((r || !m) && i && (e[$]("src") || e.srcset) && !e.complete && !J(e, H.errorClass) && J(e, H.lazyClass)) {
                        return
                    }
                    t = X(e, "lazyunveilread").detail;
                    if (r) {
                        re.updateElem(e, true, e.offsetWidth)
                    }
                    e._lazyRace = true;
                    N++;
                    s(e, t, r, a, i)
                };
                var r = ae(function () {
                    H.loadMode = 3;
                    i()
                });
                var l = function () {
                    if (H.loadMode == 3) {
                        H.loadMode = 2
                    }
                    r()
                };
                var o = function () {
                    if (m) {
                        return
                    }
                    if (f.now() - e < 999) {
                        I(o, 999);
                        return
                    }
                    m = true;
                    H.loadMode = 3;
                    i();
                    q("scroll", l, true)
                };
                return {
                    _: function () {
                        e = f.now();
                        k.elements = D.getElementsByClassName(H.lazyClass);
                        v = D.getElementsByClassName(H.lazyClass + " " + H.preloadClass);
                        q("scroll", i, true);
                        q("resize", i, true);
                        q("pageshow", function (e) {
                            if (e.persisted) {
                                var t = D.querySelectorAll("." + H.loadingClass);
                                if (t.length && t.forEach) {
                                    U(function () {
                                        t.forEach(function (e) {
                                            if (e.complete) {
                                                R(e)
                                            }
                                        })
                                    })
                                }
                            }
                        });
                        if (u.MutationObserver) {
                            new MutationObserver(i).observe(O, {childList: true, subtree: true, attributes: true})
                        } else {
                            O[P]("DOMNodeInserted", i, true);
                            O[P]("DOMAttrModified", i, true);
                            setInterval(i, 999)
                        }
                        q("hashchange", i, true);
                        ["focus", "mouseover", "click", "load", "transitionend", "animationend"].forEach(function (e) {
                            D[P](e, i, true)
                        });
                        if (/d$|^c/.test(D.readyState)) {
                            o()
                        } else {
                            q("load", o);
                            D[P]("DOMContentLoaded", i);
                            I(o, 2e4)
                        }
                        if (k.elements.length) {
                            t();
                            ee._lsFlush()
                        } else {
                            i()
                        }
                    }, checkElems: i, unveil: R, _aLSL: l
                }
            }(), re = function () {
                var i;
                var n = te(function (e, t, i, a) {
                    var r, n, s;
                    e._lazysizesWidth = a;
                    a += "px";
                    e.setAttribute("sizes", a);
                    if (j.test(t.nodeName || "")) {
                        r = t.getElementsByTagName("source");
                        for (n = 0, s = r.length; n < s; n++) {
                            r[n].setAttribute("sizes", a)
                        }
                    }
                    if (!i.detail.dataAttr) {
                        Y(e, i.detail)
                    }
                });
                var a = function (e, t, i) {
                    var a;
                    var r = e.parentNode;
                    if (r) {
                        i = s(e, r, i);
                        a = X(e, "lazybeforesizes", {width: i, dataAttr: !!t});
                        if (!a.defaultPrevented) {
                            i = a.detail.width;
                            if (i && i !== e._lazysizesWidth) {
                                n(e, r, a, i)
                            }
                        }
                    }
                };
                var e = function () {
                    var e;
                    var t = i.length;
                    if (t) {
                        e = 0;
                        for (; e < t; e++) {
                            a(i[e])
                        }
                    }
                };
                var t = ae(e);
                return {
                    _: function () {
                        i = D.getElementsByClassName(H.autosizesClass);
                        q("resize", t)
                    }, checkElems: t, updateElem: a
                }
            }(), t = function () {
                if (!t.i && D.getElementsByClassName) {
                    t.i = true;
                    re._();
                    e._()
                }
            };
        return I(function () {
            H.init && t()
        }), k = {cfg: H, autoSizer: re, loader: e, init: t, uP: Y, aC: K, rC: Q, hC: J, fire: X, gW: s, rAF: ee}
    }(e, e.document, Date);
    e.lazySizes = t,  true && module.exports && (module.exports = t)
}("undefined" != typeof window ? window : {});

/***/ }),
/* 3 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const YnfiniteConsents = {
	setup() {
		document.addEventListener('DOMContentLoaded', () => {
			const manager = document.getElementById('yn-cookies')

			if (manager) {
				if (manager.dataset.hideManager !== 'true') { 
					this.ynCheckForConsents()
				}

				document.getElementById('yn-cookies__allow-all')?.addEventListener('click', (e) => {
					e.preventDefault()
					this.ynAcceptAllConsentSettings()
				})

				document.getElementById('yn-cookies__deny-all')?.addEventListener('click', (e) => {
					e.preventDefault()
					this.ynDenyAllConsentSettings()
				})

				document.getElementById('yn-cookies__show-configuration')?.addEventListener('click', (e) => {
					e.preventDefault()
					this.ynConsentShowPage('configuration')
				})

				document.getElementById('yn-cookies__show-information')?.addEventListener('click', (e) => {
					e.preventDefault()
					this.ynConsentShowPage('information')
				})

				document.getElementById('yn-cookies__set-cookies')?.addEventListener('click', (e) => {
					e.preventDefault()
					this.ynSetConsentSettings()
				})

				const changeSelectionButton = document.getElementById('yn-cookies__change-selection')

				changeSelectionButton &&
					changeSelectionButton.addEventListener('click', (e) => {
						e.preventDefault()
						this.ynConsentShowPage('configuration')
						this.showConsent(true)
					})

				const consentButtons = document.querySelectorAll('.yn-cookie-consent--okay')

				for (let i = 0; i < consentButtons.length; i++) {
					let button = consentButtons[i]
					button.addEventListener('click', (e) => {
						e.preventDefault()
						const id = button.dataset.consentId
						this.ynAcceptConsent(id)
					})
				}
			}
		})
	},

	showConsent(hideBackButton = false) {
		const e = document.getElementById('yn-cookies')
		e && e.classList.add('yn-cookies--show')

		if (hideBackButton) {
			document.getElementById('yn-cookies__show-information').style.display = 'none'
		} else {
			document.getElementById('yn-cookies__show-information').style.display = 'block'
		}
	},

	hideConsent() {
		const e = document.getElementById('yn-cookies')
		e && e.classList.remove('yn-cookies--show')
	},

	ynConsentShowPage(e) {
		const t = document.querySelectorAll('[data-yn-cookie-page]')
		for (let e = 0; e < t.length; e++) t[e].classList.remove('yn-cookies__page--visible'), t[e].classList.add('yn-cookies__page--hidden')
		const n = document.querySelector(`[data-yn-cookie-page="${e}"]`)
		n && (n.classList.remove('yn-cookies__page--hidden'), n.classList.add('yn-cookies__page--visible'))
	},

	ynSetConsent(e, t, n) {
		const o = new Date()
		o.setTime(o.getTime() + 24 * n * 60 * 60 * 1e3)
		const i = `expires=${o.toUTCString()}`
		document.cookie = `${e}=${t};${i};path=/`
	},

	ynGetConsent(e) {
		const t = `${e}=`,
			n = decodeURIComponent(document.cookie).split(';')
		for (let e = 0; e < n.length; e++) {
			let o = n[e]
			for (; ' ' === o.charAt(0); ) o = o.substring(1)
			if (0 === o.indexOf(t)) return o.substring(t.length, o.length)
		}
		return ''
	},

	addScripts(e, t) {
		for (let n = 0; n < t.length; n++) {
			if (!document.querySelector(`script[src="${t[n]}"]`)) {
				const o = document.createElement('script')
				;(o.src = t[n]), e.appendChild(o)
			}
		}
	},

	ynCheckForConsents() {
		let e = this.ynGetConsent('ynfinite-cookies')

		if (e) {
			e = JSON.parse(e)
			let oldConsents = e.consents
			if (oldConsents == undefined){
				 oldConsents = e.activeScripts
			}
			const manager = document.getElementById('yn-cookies')
			const consents = JSON.parse(manager.getAttribute('data-consents') || '[]')
			const diff = consents.filter((x) => !oldConsents.includes(x))
			if (diff.length == 0) { 
				this.hideConsent() 
			} else { 
				this.showConsent()
			}
		} else this.showConsent()
	},

	ynSetConsentSettings() {
		const manager = document.getElementById('yn-cookies')
		const consents = JSON.parse(manager.getAttribute('data-consents') || '[]')
		const e = document.querySelector('#yn-cookies-form'),
			t = {}
		if (e) {
			const n = new FormData(e)
			t.activeScripts = n.getAll('activeScripts[]')
			t.consents = consents
		}
		;(t.done = !0), this.ynSetConsent('ynfinite-cookies', JSON.stringify(t), 365), window.location.reload()
	},

	ynAcceptAllConsentSettings() {
		const manager = document.getElementById('yn-cookies')
		const consents = JSON.parse(manager.getAttribute('data-consents') || '[]')
		const t = { done: true, activeScripts: consents, consents: consents }
		this.ynSetConsent('ynfinite-cookies', JSON.stringify(t), 365), window.location.reload()
	},

	ynDenyAllConsentSettings() {
		const manager = document.getElementById('yn-cookies')
		const consents = JSON.parse(manager.getAttribute('data-consents') || '[]')
		const t = { done: true, activeScripts: [], consents: consents }
		this.ynSetConsent('ynfinite-cookies', JSON.stringify(t), 365), window.location.reload()
	},

	ynAcceptConsent(e) {
		let t = this.ynGetConsent('ynfinite-cookies')
		;-1 === (t = JSON.parse(t)).activeScripts.findIndex((t) => t === e) && t.activeScripts.push(e), this.ynSetConsent('ynfinite-cookies', JSON.stringify(t), 365), window.location.reload()
	},

	ynDeclineConsent(e) {
		let t = this.ynGetConsent('ynfinite-cookies')
		const n = (t = JSON.parse(t)).activeScripts.findIndex((t) => t === e)
		n > -1 && t.activeScripts.splice(n, 1), this.ynSetConsent('ynfinite-cookies', JSON.stringify(t), 365), window.location.reload()
	},
}

/* harmony default export */ __webpack_exports__["default"] = (YnfiniteConsents);


/***/ }),
/* 4 */
/***/ (function(module) {

const YnfiniteForms = {
	addChangeEvent(element) {
		for (var i = 0; i < element.elements.length; i++) {
			element.elements[i].addEventListener('change', function (e) {
				e.preventDefault()
				element.submit()
			})
		}
	},

	resetForm(element) {
		element.reset()
	},

	async submitForm(element, eventType) {
		const hasProof = element.getAttribute('data-has-proof')
		const proofenHash = element.getAttribute('data-proofen-hash')

		if (!hasProof || !proofenHash) {
			console.log('Sorry, there is no proof here that you are a human. The form can not be sent.')
			return
		}

		const formSubmitButton = element.querySelector('button[type=submit]')
		formSubmitButton.dataset.label = formSubmitButton.textContent
		formSubmitButton.classList.add('show-form-spinner')
		formSubmitButton.textContent = 'Sende...'

		const ynBeforeAsyncChangeData = new Event('onPreAsyncChangeData')
		element.dispatchEvent(ynBeforeAsyncChangeData)

		const formData = new FormData(element)
		formData.set('eventAsync', true)
		formData.set('eventType', eventType)
		formData.set('method', element.getAttribute('data-ynformmethod'))
		formData.set('formId', element.getAttribute('data-ynformid'))
		formData.set('formLanguage', element.getAttribute('data-language'))
		formData.set('hasProof', hasProof)
		formData.set('proofenHash', proofenHash)
		if (element.hasAttribute('data-ynsectionid')) {
			formData.set('sectionId', element.getAttribute('data-ynsectionid'))
		}

		const action = element.getAttribute('action')

		// const data = new URLSearchParams();

		const params = new URLSearchParams(window.location.search)
		const perPage = params.get('__yPerPage')

		if (perPage) {
			formData.append('__yPerPage', perPage)
		}

		const ynBeforeAsyncChange = new Event('onPreAsyncChange')
		element.dispatchEvent(ynBeforeAsyncChange)

		const response = await fetch(action, {
			method: 'POST',
			body: formData,
		})

		if (response.ok) {
			const ynAsyncChange = new CustomEvent('onAsyncChange', {
				detail: {
					response: await response.json(),
				},
			})
			element.dispatchEvent(ynAsyncChange)

			formSubmitButton.classList.remove('show-form-spinner')
			formSubmitButton.textContent = formSubmitButton.dataset.label
		} else {
			formSubmitButton.classList.remove('show-form-spinner')
			formSubmitButton.style.backgroundColor = 'var(--error, red)'
			formSubmitButton.style.color = 'var(--light, white)'
			formSubmitButton.textContent = 'Error'
			console.error(response)
		}
	},

	addAsyncChangeEvent(element) {
		const formInputElements = element.querySelectorAll('select, input')

		for (var i = 0; i < formInputElements.length; i++) {
			formInputElements[i].addEventListener('change', async (e) => {
				e.preventDefault()
				await this.submitForm(element, 'onChange')
			})
		}
	},

	addAsyncSubmitEvent(element) {
		element.addEventListener('submit', async (e) => {
			e.preventDefault()
			await this.submitForm(element, 'onSubmit')
		})
	},

	setup() {
		document.addEventListener('DOMContentLoaded', () => {
			const forms = document.querySelectorAll('[data-ynform=true]')

			forms.forEach((form) => {
				if (form.hasAttribute('data-onchange')) {
					if (form.dataset.onchange === 'async') {
						this.addAsyncChangeEvent(form)
					} else {
						this.addChangeEvent(form)
					}
				}

				if (form.hasAttribute('data-onsubmit')) {
					if (form.dataset.onsubmit === 'async') {
						this.addAsyncSubmitEvent(form)
					}
				}

				// Handle reset action

				const resetButton = form.querySelector("button[type='reset']")
				if (resetButton) {
					resetButton.addEventListener('click', async (e) => {
						const formInputElements = form.querySelectorAll('select, input')

						for (var i = 0; i < formInputElements.length; i++) {
							formInputElements[i].value = ''
						}

						await this.submitForm(form)
					})
				}

				// Handle new form

				const newFormLink = form.querySelector('.yn-form-response__new-form')
				if (newFormLink) {
					newFormLink.addEventListener('click', (e) => {
						e.preventDefault()
						this.resetForm(form)

						newFormLink.closest('form').querySelector('.form-content').classList.remove('inactive')
						newFormLink.closest('.yn-form-response').classList.remove('active')
					})
				}

				// Handle list fields
				const listFields = form.querySelectorAll('.yn-listForm-wrapper')

				listFields.forEach((listField) => {
					const newAction = listField.querySelector('.yn-listForm-actions-new')

					const rowTemplate = listField.querySelector('#listField_' + listField.dataset.ynformalias)

					const dataContainer = listField.querySelector('.yn-listForm-data')

					newAction.addEventListener('click', (e) => {
						e.preventDefault()
						const newRow = rowTemplate.content.cloneNode(true)
						newRow.className = 'yn-listForm-row'

						const deleteButton = newRow.querySelector('.yn-listForm-actions-delete')

						const fields = newRow.querySelectorAll('[data-ynfield=true]')
						fields.forEach((f) => {
							f.setAttribute('name', f.name.replace('::count::', dataContainer.childElementCount))
						})

						dataContainer.appendChild(newRow)

						deleteButton.addEventListener('click', (e) => {
							e.preventDefault()
							const row = e.target.closest('.yn-listForm-row')
							dataContainer.removeChild(row)
						})
					})
				})
			})
		})
	},

	enableForm(form) {
		const fieldset = form.querySelector('fieldset')
		fieldset.disabled = false
	},

	disableForm(form) {
		const fieldset = form.querySelector('fieldset')
		fieldset.disabled = true
	},

	updateUrl(form) {
		const formData = new FormData(form)

		const data = new URLSearchParams()

		const params = new URLSearchParams(window.location.search)
		const perPage = params.get('__yPerPage')

		if (perPage) {
			data.append('__yPerPage', perPage)
		}

		for (const pair of formData) {
			if (pair[1]) {
				data.append(pair[0], pair[1])
			}
		}

		let newHref = `${window.location.protocol}//${window.location.hostname}${window.location.pathname}`
		if (data.toString()) {
			newHref += `?${data.toString()}`
		}

		history.pushState({}, '', newHref)
	},

	repopulateForm(form, data) {
		const keys = Object.keys(data.fields)
		for (var i = 0; i < keys.length; i++) {
			const element = data.fields[keys[i]]
			const formElement = form.querySelector(`[name="fields[${element.alias}]"]`)

			if (!formElement) break

			let markup = `${element.options.map((option) => `<option value="${option.value}" ${option.value === element.value ? 'selected' : ''}>${option.label}</option>`).join('')}`
			if (!formElement.options[0].value) {
				markup = `<option value>${formElement.options[0].text}</option>${markup}`
			}

			formElement.innerHTML = markup
		}
	},

	showResponse(form, data) {
		const responseContainer = form.querySelector('.yn-form-response')
		const formContent = form.querySelector('.form-content')

		const innerContainer = responseContainer.querySelector('.yn-form-response__inner')

		formContent.classList.add('inactive')
		innerContainer.innerHTML = data.rendered
		responseContainer.classList.add('active')
		responseContainer.scrollIntoView({
			behavior: 'auto',
			block: 'center',
			inline: 'center',
		})
	},
}

module.exports = YnfiniteForms


/***/ }),
/* 5 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var crypto_js_sha256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
/* harmony import */ var crypto_js_sha256__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto_js_sha256__WEBPACK_IMPORTED_MODULE_0__);


class Block {
    constructor(data, previousHash = '') {
        this.previousHash = previousHash;
        this.timestamp = Date.now();
        this.data = data;

        this.hash = this.calculateHash();

        this.nonce = 0;
    }

    calculateHash() {
        return crypto_js_sha256__WEBPACK_IMPORTED_MODULE_0___default()(this.previousHash + this.timestamp + JSON.stringify(this.data)).toString();
    }

    startProofOfWork(difficulty = 4) {
        if (window.Worker) {
            const blockWorker = new Worker('/assets/vendor/ypsolution/js/worker.min.js');

            blockWorker.onmessage = (e) => {
                this.hash = e.data

                this.data.form.dataset.hasProof = "true";
                this.data.form.dataset.proofenHash = this.hash;

                const formSubmitButton = this.data.form.querySelector("button[type=submit]");
                 
                formSubmitButton.classList.remove("show-form-spinner")
                formSubmitButton.textContent = formSubmitButton.dataset.label;

                blockWorker.terminate();
                console.timeEnd();
            }

            console.time();

            blockWorker.postMessage({form: JSON.stringify(this.data.form), previousHash: this.previousHash, timestamp: this.timestamp, difficulty})
        }
    }
}


class BlockChain {
    constructor() {
        this.chain = [this.createGenesisBlock()];
    }

    getLatestBlock() {  
        return this.chain[this.chain.length - 1];
    }

    addBlock(newBlock){
        newBlock.previousHash = this.getLatestBlock().hash;
        this.chain.push(newBlock);

        return newBlock;
    }

    createGenesisBlock() {
        return new Block("Genesis block", "0");
    }
}

const YnfiniteBotProtection = {
    setup() {
        document.addEventListener("DOMContentLoaded", () => {
            const blockchain = new BlockChain();
           
            const forms = document.querySelectorAll("form[data-ynform=true][method=post]");
            if(forms.length === 0) {
                return;
            }

            forms.forEach((form) => {
                form.dataset.hasProof = "false";
                form.dataset.proofenHash = "";

                const formSubmitButton = form.querySelector("button[type=submit]");

                form.addEventListener('change', function() {
                    if(form.dataset.hasProof === "false" && !form.dataset.working) {
                        form.dataset.working = true;

                        formSubmitButton.dataset.label = formSubmitButton.textContent;
                        formSubmitButton.classList.add("show-form-spinner")
                        formSubmitButton.textContent = "Warte auf Bot-Prüfung...";
                
                        const block = blockchain.addBlock(new Block({form: form}))
                        block.startProofOfWork()
                    }
                });
            });
        })
    },
}

/* harmony default export */ __webpack_exports__["default"] = (YnfiniteBotProtection);

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(7));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native crypto in web worker (Browser)
	    if (typeof self !== 'undefined' && self.crypto) {
	        crypto = self.crypto;
	    }

	    // Native crypto from worker
	    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
	        crypto = globalThis.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.crypto) {
	        crypto = __webpack_require__.g.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __webpack_require__(8);
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }());

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var j = 0; j < thatSigBytes; j += 4) {
	                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));

/***/ }),
/* 8 */
/***/ (function() {

/* (ignored) */

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _js_general__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _js_general__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_js_general__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _js_lazysize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _js_lazysize__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_js_lazysize__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _js_cookies__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _js_forms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _js_forms__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_js_forms__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _js_botprotection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
//JS Files







_js_cookies__WEBPACK_IMPORTED_MODULE_2__["default"].setup()
_js_forms__WEBPACK_IMPORTED_MODULE_3___default().setup()
_js_botprotection__WEBPACK_IMPORTED_MODULE_4__["default"].setup()

window.$_yn = {
	forms: { 
		updateUrl: (_js_forms__WEBPACK_IMPORTED_MODULE_3___default().updateUrl),
		repopulate: (_js_forms__WEBPACK_IMPORTED_MODULE_3___default().repopulateForm),
		enable: (_js_forms__WEBPACK_IMPORTED_MODULE_3___default().enableForm),
		disable: (_js_forms__WEBPACK_IMPORTED_MODULE_3___default().disableForm),
		showResponse: (_js_forms__WEBPACK_IMPORTED_MODULE_3___default().showResponse),
	},
}


}();
/******/ })()
;
//# sourceMappingURL=app.min.js.map